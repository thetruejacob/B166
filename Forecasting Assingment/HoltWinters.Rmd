---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

Using Holt-Winters, or Triple-Exponential Smoothing 

```{r}
require("stats")
require("forecast")
require("MLmetrics")

df = read.table("co2_mm_mlo.txt", 
                col.names = c("Year", "Month", "Date", "average", "interpolated", "trend", "days"))
df[,8] = as.Date(paste(df$Year, df$Month, 1, sep = "-"), format = "%Y-%m-%d")
plot(df[,8], df[,5], type = "l", xlab = "Year", ylab = "Yearly Average", 
     main = "Mauna Loa Yearly Carbon Dioxide Concentration")
plot(1958:2018, tapply(df[,5], format(df[,8], "%Y"), mean), xlab = "Year", 
     ylab = "Yearly Average", main = "Mean Annual CO2 Levels", type = "l")
plot(df[647:718, 8], df[647:718, 4], type = "o", xlab = "Years", 
     ylab = "Average CO2 Level (ppm)", main = "Recent Monthly Mean CO2 Levels")
```

This is for a simple prediction on the training data
```{r}
shortts = ts(df[647:718, 4], frequency = 12, start = c(2012, 1))  # only 2012-2017
fullts = ts(df[1:718,5], frequency = 12, start = c(1958, 3))      # 1953 - 2017
plot(decompose(fullts))
plot(HoltWinters(shortts))
plot(HoltWinters(fullts))
MAPE(HoltWinters(shortts)$fitted[,1], df[659:718, 4])
MAPE(HoltWinters(fullts)$fitted[,1], df[13:718,5])
```

This is for a prediction of future seasonal data
```{r}
pred = data.frame(predict(stats::HoltWinters(fullts), n.ahead = 50, prediction.interval = 1))
pred$date = seq(as.Date("2018-01-01"), by = "month", length.out = nrow(pred))

plot(df[647:726,8], df[647:726, 4], type = "o", 
     main = "Predicted CO2 (Holt-Winters)", xlab = "Year", ylab = "CO2 (ppm)", 
     xlim = range(pred[,4], df[647:726,8]), ylim = range(pred[,2],df[647:726, 4] ))
matlines(pred[,4], pred[,-4], lwd = c(2,1,1), lty = c(1,2,2))
```
Prediction intervals for forecasting based on exponential smoothing methods require the forecast errors to be uncorrelated and normally distributed with mean zero and constant variance.

In contrast, Autoregressive Integrated Moving Average (ARIMA) models include an explicit statistical model for the irregular component of a time series, allowing non-zero autocorrelations in the irregular component. ARIMA models also require stationary time series.

Using ARIMA should be even more effective, because it includes the 
```{r}
residuals = fullts - season(fullts,12) - trend(fullts,12)
test(residuals)
auto.arima(residuals)

sarima = stats::arima(fullts, order = c(2,1,0), seasonal = list(order = c(2,1,1), period = 12))
sarimapred = data.frame(predict(sarima, n.ahead = 50, prediction.interval = 1))
sarimapred[,3:4] = cbind(sarimapred[,1] - 2*sarimapred[,2], sarimapred[,1] + 2*sarimapred[,2])
sarimapred$date = seq(as.Date("2018-01-01"), by = "month", length.out = nrow(sarimapred))

plot(df[647:726,8], df[647:726, 4], type = "o", main = "Predicted CO2 (SARIMA)",
     xlab = "Year", ylab = "CO2 (ppm)", xlim = range(sarimapred[,5], df[647:726,8]), 
     ylim = range(sarimapred[,4],df[647:726, 4] ))
matlines(sarimapred[,5], sarimapred[,c(1,3,4)], lwd = c(2,1,1), lty = c(1,2,2))

```
```{r}
library(GPFDA)
data(co2)
data_co2=co2
# store data into matrix and remove missing values
y=data.matrix(data_co2[,!names(data_co2)%in%'Annual_Average'])
data_co2[,!names(data_co2)%in%'Annual_Average']
y=matrix(t(y),ncol=1)
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)
X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)

?seq
```

Using Gaussian Processes
```{r}
library(GPFDA)
data(co2)
data_co2=co2
# store data into matrix and remove missing values
y=data.matrix(data_co2[,!names(data_co2)%in%'Annual_Average'])
y=matrix(t(y),ncol=1)
y=matrix(t(y),ncol=1)
x=1:612/12; x[y<0]=NA
mat=cbind(y,x)
mat=na.omit(mat)
X=as.matrix(mat[,2])
Y=as.matrix(mat[,1])
x=as.matrix(seq(1,612,len=1000)/12)
# First covariance matrix
system.time(a1 <- gpr(as.matrix(X),as.matrix(Y),c('pow.ex'),mean='t',trace=2))
system.time(b1 <- gppredict(a1,Data.new=as.matrix(x)))
# plot(a1)
# plot(b1)
upper=b1$pred.mean+1.96*b1$pred.sd;
lower=b1$pred.mean-1.96*b1$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by powered exponential", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b1$pred.mean,col=4,lwd=0.8)
# Second covariance matrix
a2 <- gpr(as.matrix(X),as.matrix(Y),c('rat.qu'),mean='t',trace=2)
b2 <- gppredict(a2,Data.new=as.matrix(x))
# plot(a2)
# plot(b2)
upper=b2$pred.mean+1.96*b2$pred.sd;
lower=b2$pred.mean-1.96*b2$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by rational quadratic", xlab="input ",ylab="response")
 polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
 points(X,Y,pch=2,col=2,cex=0.1)
 # lines(X[,1],Y)
 lines(x,b2$pred.mean,col=4,lwd=0.8)
 
 ## Define the customized covariance matrix 
 cov.custom=function(hyper,Data,Data.new=NULL){
    hyper=lapply(hyper,exp);
    datadim=dim(Data)
    if(is.null(Data.new)) Data.new=Data
    A1=xixj_sta(Data,Data.new,hyper$custom.w) #exp(w)*||x-x'||^2
    mdim=dim(Data);mdim.new=dim(Data.new)
    cov.=sapply(1:mdim[1],function(i) matrix(rep(Data[i,],mdim.new[1]),nrow=mdim.new[1],byrow=T)-Data.new)
    cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
    if(mdim[2]>1){
      for(i in 1:(mdim[2]-1)){
        cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
      cov.= cov..+cov.   # x-x'
      }
    A2=hyper$custom.u*(sin(pi*cov.))^2
    return(hyper$custom.v*exp(-A1-A2))
 }
 
# Define the first derivative of the customized covariance matrix 
DCov.custom.w=function(hyper,data,AlphaQ){
  Dcov=cov.custom(hyper,data)
  A1=-xixj_sta(data,data,hyper$custom.w)
  out=Dcov %*% A1
  out=sum(out*AlphaQ)
  return(out)
}

# Define the second derivative of the customized covariance matrix 
D2custom.w=function(hyper,data,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,data)
  A1=-xixj_sta(data,data,hyper$custom.w)
  wD2=Dcov%*%(A1^2+A1)
  wD1=Dcov%*%A1
  D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
  return(D2c.w)
}

D2custom.w=function(hyper,data,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,data)
  A1=-xixj_sta(data,data,hyper$custom.w)
  wD2=Dcov%*%(A1^2+A1)
  wD1=Dcov%*%A1
  D2c.w=D2(wD1,wD2,inv.Q,Alpha.Q)
  return(D2c.w)
}

D2custom.u=function(hyper,data,inv.Q,Alpha.Q){
  Dcov=cov.custom(hyper,data)
  hyper=lapply(hyper,exp)
  mdim=dim(data);mdim.new=mdim
  cov.=sapply(1:mdim[1],function(i) matrix(rep(data[i,],mdim.new[1]),nrow=mdim.new[1],byrow=T)-data)
  cov..=matrix(0,ncol=mdim[1],nrow=mdim.new[1])
  if(mdim[2]>1){
    for(i in 1:(mdim[2]-1)){
      cov..=cov..+cov.[1:mdim.new[1],];cov.=cov.[-(1:mdim.new[1]),]}
    cov.=cov..+cov.
    }
  A2=-hyper$custom.u*(sin(pi*cov.))^2  
  uD2=Dcov%*%(A2^2+A2)
  uD1=Dcov%*%A2
  D2c.u=D2(uD1,uD2,inv.Q,Alpha.Q)
  return(D2c.u)
}

D2custom.v=function(hyper,data,inv.Q,Alpha.Q){
  vD1=cov.custom(hyper,data)
  vD2=vD1
  D2c.v=D2(vD1,vD2,inv.Q,Alpha.Q)
  return(D2c.v)
}

# Define the diagonal of the customized covariance matrix 
diag.custom=function(hyper,data){
  Qstar=rep(exp(hyper$custom.v),dim(data)[1])
  return(Qstar)
}

# Use all three covariance matrix
a3 <- gpr(as.matrix(X),as.matrix(Y),Cov=c('pow.ex','custom','rat.qu'),
          NewHyper=c('custom.w','custom.u','custom.v'),mean='t',trace=2)

b3 <- gppredict(a3,Data.new=as.matrix(x))
# plot(a3)
# plot(b3)

upper=b3$pred.mean+1.96*b3$pred.sd;
lower=b3$pred.mean-1.96*b3$pred.sd;
plot(-100,-100,col=0,xlim=range(X,x),ylim=range(upper,lower,Y),main="Prediction by sum of three kernels", xlab="input ",ylab="response")
polygon(c(x, rev(x)), c(upper, rev(lower)),col = "grey", border = NA)
points(X,Y,pch=2,col=2,cex=0.1)
# lines(X[,1],Y)
lines(x,b3$pred.mean,col=4,lwd=0.8)
plot(a1)
plot(b1)
```
```{r}
plot(a1)
plot(b1)
```


```{r}
MAPE(pred[1:8,1], df[719:726,5])
MAPE(sarimapred[1:8,1], df[719:726,5])
```

